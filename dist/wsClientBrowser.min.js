var S=Object.defineProperty;var l=(y,h)=>S(y,"name",{value:h,configurable:!0});(()=>{"use strict";var y={};class h{constructor(){this.activeOns=[]}emit(t,e={}){const o=new CustomEvent(t,{detail:e});window.dispatchEvent(o)}on(t,e){const o=l(s=>{const n=this._getDetailValues(s.detail);e.call(null,...n)},"listenerWindow");this._removeOne(t,e),this.activeOns.push({eventName:t,listener:e,listenerWindow:o}),window.addEventListener(t,o)}once(t,e){const o=l(s=>{const n=this._getDetailValues(s.detail);e.call(null,...n),this._removeOne(t,e,o)},"listenerWindow");window.addEventListener(t,o,{once:!0})}off(t,e){this._removeOne(t,e)}offAll(t){let e=0;for(const o of this.activeOns)o.eventName===t&&(window.removeEventListener(o.eventName,o.listenerWindow),this.activeOns.splice(e,1)),e++}getListeners(){return{...this.activeOns}}_removeOne(t,e){if(!e)throw new Error("eventEmitter._removeOne Error: listener is not defined");let o=0;for(const s of this.activeOns)s.eventName===t&&s.listener.toString()===e.toString()&&(window.removeEventListener(s.eventName,s.listenerWindow),this.activeOns.splice(o,1)),o++}_getDetailValues(t){return t?Object.values(t):[]}}l(h,"EventEmitter");const a=new h;class k{generateID(){const e=Math.random().toString().replace("0.","").substring(0,3);return new Date().toISOString().replace(/\-/g,"").replace(/\:/g,"").replace("T","").replace("Z","").replace(".","")+e}nowTime(){const t=new Date;return new Intl.DateTimeFormat("en-us",{weekday:"long",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3,hour12:!1,timeZone:"UTC"}).format(t)}async sleep(t){await new Promise(e=>setTimeout(e,t))}printBuffer(t){console.log(t.toString("hex").match(/../g).join(" "))}tableOfBytes(t,e){let o=t.toString("hex").match(/../g);return o=o.map((n,r)=>(r===0&&(n=`
 `+n),(r+1)%e===0&&(n+=`
`),n)),o.join(" ")}}l(k,"Helper");const g=new k;class O{constructor(){this.delimiter=""}incoming(t){let e=!1,o;try{t=t.replace(this.delimiter,""),o=JSON.parse(t);const s=Object.keys(o);e=this._testFields(s)}catch{e=!1}if(e)return o;throw new Error(`Incoming message doesn't have valid "jsonRWS" subprotocol format. msg:: "${t}"`)}outgoing(t){const e=Object.keys(t);if(this._testFields(e))return JSON.stringify(t)+this.delimiter;throw new Error(`Outgoing message doesn't have valid "jsonRWS" subprotocol format. msg:: ${JSON.stringify(t)}`)}async processing(t,e,o,s,n){const r=t.id,u=t.from,m=t.to,c=t.cmd,p=t.payload;if(c==="socket/sendone"){const i=t.to,d=await s.findOne({id:i});await o.sendOne(t,d)}else if(c==="socket/send"){const i=m.map(f=>f),d=await s.find({id:{$in:i}});await o.send(t,d)}else if(c==="socket/broadcast")await o.broadcast(t,e);else if(c==="socket/sendall")await o.sendAll(t);else if(c==="socket/nick"){const i=t.payload;try{await s.setNick(e,i),t.payload=e.extension.nickname}catch(d){t.cmd="error",t.payload=d.message}e.extension.sendSelf(t)}else if(c==="room/enter"){const i=p;s.roomEnter(e,i),t.payload=`Entered in the room '${i}'`,e.extension.sendSelf(t)}else if(c==="room/exit"){const i=p;s.roomExit(e,p),t.payload=`Exited from the room '${i}'`,e.extension.sendSelf(t)}else if(c==="room/exitall")s.roomExitAll(e),t.payload="Exited from all rooms",e.extension.sendSelf(t);else if(c==="room/send"){const i=m;await o.sendRoom(t,e,i)}else if(c==="route")n.emit("route",t,e,o,s,n);else if(c==="question/socket/id")t.payload=e.extension.id,e.extension.sendSelf(t);else if(c==="question/socket/list"){const d=(await s.find()).map(f=>({id:f.extension.id,nickname:f.extension.nickname}));t.payload=d,e.extension.sendSelf(t)}else if(c==="question/room/list"){const i=await s.roomList();t.payload=i,e.extension.sendSelf(t)}else if(c==="question/room/listmy"){const i=await s.roomListOf(t.from);t.payload=i,e.extension.sendSelf(t)}}_testFields(t){const e=["id","from","to","cmd","payload"],o=["id","from","to","cmd"];let s=!0;for(const n of t)if(e.indexOf(n)===-1){s=!1;break}for(const n of o)if(t.indexOf(n)===-1){s=!1;break}return s}}l(O,"JsonRWS");const x=new O;class b{constructor(){this.delimiter=""}incoming(t){return t=t.replace(this.delimiter,""),t}outgoing(t){let e=t;return typeof t=="object"&&(e=JSON.stringify(t)),e+=this.delimiter,e}async process(){}}l(b,"Raw");const v=new b;class E{constructor(t){if(this.wcOpts=t,!t.wsURL||!/^ws:\/\//.test(t.wsURL))throw new Error("Bad websocket URL");t.connectTimeout||(this.wcOpts.connectTimeout=8e3),t.reconnectAttempts===void 0&&(this.wcOpts.reconnectAttempts=6),t.reconnectDelay===void 0&&(this.wcOpts.reconnectDelay=5e3),t.questionTimeout===void 0&&(this.wcOpts.questionTimeout=13e3),t.subprotocols||(this.wcOpts.subprotocols=["jsonRWS","raw"]),t.debug||(this.wcOpts.debug=!1),t.debug_DataParser||(this.wcOpts.debug_DataParser=!1),this.wsocket,this.socketID,this.attempt=1,this.subprotocolLib,this.helper=g}connect(){this.socketID=this.helper.generateID();let t=this.wcOpts.wsURL;return/\?[a-zA-Z0-9]/.test(t)?t+=`&socketID=${this.socketID}`:t+=`socketID=${this.socketID}`,this.wsocket=new WebSocket(t,this.wcOpts.subprotocols),this.onEvents(),new Promise(e=>{a.once("connected",()=>{e(this.wsocket)})})}disconnect(){this.wsocket&&this.wsocket.close(),this.blockReconnect()}async reconnect(){const t=this.wcOpts.reconnectAttempts,e=this.wcOpts.reconnectDelay;this.attempt<=t&&(await this.helper.sleep(e),this.connect(),console.log(`Reconnect attempt #${this.attempt} of ${t} in ${e}ms`),this.attempt++)}blockReconnect(){this.attempt=this.wcOpts.reconnectAttempts+1}onEvents(){this.wsocket.onopen=async t=>{console.log(`WS Connection opened -- socketID: ${this.socketID}, subprotocol(handshaked): "${this.wsocket.protocol}"`),this.onMessage(),this.attempt=1,this.wsocket&&this.wsocket.protocol==="raw"?this.subprotocolLib=v:this.wsocket&&this.wsocket.protocol==="jsonRWS"?this.subprotocolLib=x:this.subprotocolLib=v,a.emit("connected")},this.wsocket.onclose=t=>{console.log("WS Connection closed"),delete this.wsocket,delete this.socketID,this.reconnect(),a.emit("disconnected")},this.wsocket.onerror=t=>{}}onMessage(){if(!this.wsocket)return;const t=this.wsocket.protocol;this.wsocket.addEventListener("message",e=>{try{const o=e.data;if(this._debugger("Received::",o),!new RegExp(this.subprotocolLib.delimiter).test(o))return;const n=this.subprotocolLib.incoming(o),r={msg:n,msgSTR:o};n.cmd==="route"&&t==="jsonRWS"?a.emit("route",r):n.cmd==="server-error"&&t==="jsonRWS"?(this.blockReconnect(),a.emit("server-error",r)):/^question\//.test(n.cmd)&&t==="jsonRWS"?a.emit("question",r):a.emit("message",r)}catch(o){a.emit("message-error",o)}})}async carryOut(t,e,o){const s=this.helper.generateID(),n=this.socketID;if(!Array.isArray(t)&&typeof t!="string")throw new Error('ERRcarryOut: "to" argument must be string');if(Array.isArray(t)){for(const m of t)if(typeof m!="string")throw new Error('ERRcarryOut: "to" argument must be string')}const r={id:s,from:n,to:t,cmd:e,payload:o},u=this.subprotocolLib.outgoing(r);return await this.socketWrite(u),this._debugger("Sent::",u),r}async socketWrite(t){if(await new Promise(e=>setTimeout(e,0)),this.wsocket&&this.wsocket.readyState===1)this.wsocket.send(t);else throw new Error("Socket is not writeble or doesn't exist")}async sendOne(t,e){const o="socket/sendone";return await this.carryOut(t,o,e)}async send(t,e){const o="socket/send";return await this.carryOut(t,o,e)}async broadcast(t){const e="0",o="socket/broadcast";return await this.carryOut(e,o,t)}async sendAll(t){const e="0",o="socket/sendall";return await this.carryOut(e,o,t)}async question(t){const e=this.socketID,o=void 0;return await this.carryOut(e,t,o),new Promise(async(s,n)=>{const r=l(u=>{u.cmd===t&&s(u)},"listener");this.once("question",r),await this.helper.sleep(this.wcOpts.questionTimeout),this.off("question",r),n(new Error(`No answer for the question: ${t}`))})}async questionSocketId(){const t=await this.question("question/socket/id");return this.socketID=t.payload,this.socketID}async questionSocketList(){return(await this.question("question/socket/list")).payload}async questionRoomList(){return(await this.question("question/room/list")).payload}async questionRoomListmy(){return(await this.question("question/room/listmy")).payload}async roomEnter(t){const e="0",o="room/enter",s=t;return await this.carryOut(e,o,s)}async roomExit(t){const e="0",o="room/exit",s=t;return await this.carryOut(e,o,s)}async roomExitAll(){const t="0",e="room/exitall";return await this.carryOut(t,e,void 0)}async roomSend(t,e){const o=t,s="room/send";return await this.carryOut(o,s,e)}async setNick(t){const e="0",o="socket/nick",s=t;return await this.carryOut(e,o,s)}async route(t,e){const o="0",s="route",n={uri:t,body:e};return await this.carryOut(o,s,n)}on(t,e){a.on(t,e)}once(t,e){return a.once(t,e)}off(t,e){return a.off(t,e)}offAll(t){return a.offAll(t)}_debugger(...t){const e=t.join("");this.wcOpts.debug&&console.log(e)}}l(E,"WsClientBrowser13");const D=E;typeof window<"u"&&(window.mikosoft||(window.mikosoft={}),window.mikosoft.WsClientBrowser=D)})();

//# sourceMappingURL=wsClientBrowser.min.js.map