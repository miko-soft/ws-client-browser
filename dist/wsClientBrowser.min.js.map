{"version":3,"file":"wsClientBrowser.min.js","mappings":"2GAGA,MAAMA,CAAa,CAEjB,aAAc,CACZ,KAAK,UAAY,CAAC,CACpB,CASA,KAAKC,EAAWC,EAAS,CAAC,EAAG,CAC3B,MAAMC,EAAM,IAAI,YAAYF,EAAW,CAAE,OAAAC,CAAO,CAAC,EACjD,OAAO,cAAcC,CAAG,CAC1B,CASA,GAAGF,EAAWG,EAAU,CACtB,MAAMC,EAAiB,EAAAC,GAAS,CAC9B,MAAMC,EAAe,KAAK,iBAAiBD,EAAM,MAAM,EACvDF,EAAS,KAAK,KAAM,GAAGG,CAAY,CACrC,EAHuB,kBAKvB,KAAK,WAAWN,EAAWG,CAAQ,EACnC,KAAK,UAAU,KAAK,CAAE,UAAAH,EAAW,SAAAG,EAAU,eAAAC,CAAe,CAAC,EAC3D,OAAO,iBAAiBJ,EAAWI,CAAc,CACnD,CASA,KAAKJ,EAAWG,EAAU,CACxB,MAAMC,EAAiB,EAAAC,GAAS,CAC9B,MAAMC,EAAe,KAAK,iBAAiBD,EAAM,MAAM,EACvDF,EAAS,KAAK,KAAM,GAAGG,CAAY,EAEnC,KAAK,WAAWN,EAAWG,EAAUC,CAAc,CACrD,EALuB,kBAOvB,OAAO,iBAAiBJ,EAAWI,EAAgB,CAAE,KAAM,EAAK,CAAC,CACnE,CASA,IAAIJ,EAAWG,EAAU,CACvB,KAAK,WAAWH,EAAWG,CAAQ,CACrC,CASA,OAAOH,EAAW,CAChB,IAAIO,EAAM,EACV,UAAWC,KAAY,KAAK,UACtBA,EAAS,YAAcR,IACzB,OAAO,oBAAoBQ,EAAS,UAAWA,EAAS,cAAc,EACtE,KAAK,UAAU,OAAOD,EAAK,CAAC,GAE9BA,GAEJ,CAOA,cAAe,CACb,MAAO,CAAE,GAAG,KAAK,SAAU,CAC7B,CAUA,WAAWP,EAAWG,EAAU,CAC9B,GAAI,CAACA,EAAY,MAAM,IAAI,MAAM,wDAAwD,EACzF,IAAII,EAAM,EACV,UAAWC,KAAY,KAAK,UACtBA,EAAS,YAAcR,GAAaQ,EAAS,SAAS,SAAS,IAAML,EAAS,SAAS,IACzF,OAAO,oBAAoBK,EAAS,UAAWA,EAAS,cAAc,EACtE,KAAK,UAAU,OAAOD,EAAK,CAAC,GAE9BA,GAEJ,CAQA,iBAAiBN,EAAQ,CAEvB,OADuBA,EAAS,OAAO,OAAOA,CAAM,EAAI,CAAC,CAE3D,CAMF,CA/HM,EAAAF,EAAA,gBAkIN,QAAe,IAAIA,ECrInB,MAAMU,CAAO,CAQX,YAAa,CAEX,MAAMC,EADM,KAAK,OAAO,EAAE,SAAS,EACnB,QAAQ,KAAM,EAAE,EAAE,UAAU,EAAG,CAAC,EAWhD,OATkB,IAAI,KAAK,EACL,YAAY,EAC/B,QAAQ,MAAO,EAAE,EACjB,QAAQ,MAAO,EAAE,EACjB,QAAQ,IAAK,EAAE,EACf,QAAQ,IAAK,EAAE,EACf,QAAQ,IAAK,EAAE,EAEDA,CAEnB,CAOA,SAAU,CACR,MAAMC,EAAM,IAAI,KAahB,OAZkB,IAAI,KAAK,eAAe,QAAS,CACjD,QAAS,OACT,KAAM,UACN,MAAO,UACP,IAAK,UACL,KAAM,UACN,OAAQ,UACR,OAAQ,UACR,uBAAwB,EACxB,OAAQ,GACR,SAAU,KACZ,CAAC,EACgB,OAAOA,CAAG,CAC7B,CAQA,MAAM,MAAMC,EAAI,CACd,MAAM,IAAI,QAAQC,GAAW,WAAWA,EAASD,CAAE,CAAC,CACtD,CAUA,YAAYE,EAAM,CAChB,QAAQ,IAAIA,EAAK,SAAS,KAAK,EAAE,MAAM,KAAK,EAAE,KAAK,GAAG,CAAC,CACzD,CAQA,aAAaA,EAAMC,EAAQ,CACzB,IAAIC,EAAQF,EAAK,SAAS,KAAK,EAAE,MAAM,KAAK,EAG5C,OAAAE,EAAQA,EAAM,IAAI,CAACC,EAAMC,KACnBA,IAAQ,IAAKD,EAAO;AAAA,GAAQA,IAC3BC,EAAM,GAAKH,IAAW,IAAKE,GAAQ;AAAA,GACjCA,EACR,EAEWD,EAAM,KAAK,GAAG,CAE5B,CAGF,CAzFM,EAAAP,EAAA,UA8FN,QAAe,IAAIA,EC/EnB,MAAMU,CAAQ,CAEZ,aAAc,CACZ,KAAK,UAAY,GACnB,CAUA,SAASC,EAAQ,CACf,IAAIC,EAAK,GACLC,EACJ,GAAI,CACFF,EAASA,EAAO,QAAQ,KAAK,UAAW,EAAE,EAC1CE,EAAM,KAAK,MAAMF,CAAM,EACvB,MAAMG,EAAmB,OAAO,KAAKD,CAAG,EACxCD,EAAK,KAAK,YAAYE,CAAgB,CACxC,MAAE,CACAF,EAAK,EACP,CAEA,GAAIA,EAAM,OAAOC,EACV,MAAM,IAAI,MAAM,4EAA6EF,IAAS,CAC/G,CAYA,SAASE,EAAK,CACZ,MAAMC,EAAmB,OAAO,KAAKD,CAAG,EAGxC,GAFW,KAAK,YAAYC,CAAgB,EAI1C,OADe,KAAK,UAAUD,CAAG,EAAI,KAAK,UAG1C,MAAM,IAAI,MAAM,2EAA4E,KAAK,UAAUA,CAAG,GAAG,CAErH,CAaA,MAAM,WAAWA,EAAKE,EAAQC,EAAcC,EAAeC,EAAc,CACvE,MAAMC,EAAKN,EAAI,GACTO,EAAOP,EAAI,KACXQ,EAAKR,EAAI,GACTS,EAAMT,EAAI,IACVU,EAAUV,EAAI,QAIpB,GAAIS,IAAQ,iBAAkB,CAE5B,MAAMH,EAAKN,EAAI,GACTW,EAAW,MAAMP,EAAc,QAAQ,CAAE,GAAAE,CAAG,CAAC,EACnD,MAAMH,EAAa,QAAQH,EAAKW,CAAQ,CAC1C,SAESF,IAAQ,cAAe,CAE9B,MAAMG,EAAYJ,EAAG,IAAIK,GAAYA,CAAQ,EACvCC,EAAU,MAAMV,EAAc,KAAK,CAAE,GAAI,CAAE,IAAKQ,CAAU,CAAE,CAAC,EACnE,MAAMT,EAAa,KAAKH,EAAKc,CAAO,CACtC,SAESL,IAAQ,mBAEf,MAAMN,EAAa,UAAUH,EAAKE,CAAM,UAGjCO,IAAQ,iBAEf,MAAMN,EAAa,QAAQH,CAAG,UAGvBS,IAAQ,cAAe,CAE9B,MAAMM,EAAWf,EAAI,QACrB,GAAI,CACF,MAAMI,EAAc,QAAQF,EAAQa,CAAQ,EAC5Cf,EAAI,QAAUE,EAAO,UAAU,QACjC,OAASc,EAAP,CACAhB,EAAI,IAAM,QACVA,EAAI,QAAUgB,EAAI,OACpB,CACAd,EAAO,UAAU,SAASF,CAAG,CAC/B,SAISS,IAAQ,aAAc,CAE7B,MAAMQ,EAAWP,EACjBN,EAAc,UAAUF,EAAQe,CAAQ,EACxCjB,EAAI,QAAU,wBAAwBiB,KACtCf,EAAO,UAAU,SAASF,CAAG,CAC/B,SAESS,IAAQ,YAAa,CAE5B,MAAMQ,EAAWP,EACjBN,EAAc,SAASF,EAAQQ,CAAO,EACtCV,EAAI,QAAU,yBAAyBiB,KACvCf,EAAO,UAAU,SAASF,CAAG,CAC/B,SAESS,IAAQ,eAEfL,EAAc,YAAYF,CAAM,EAChCF,EAAI,QAAU,wBACdE,EAAO,UAAU,SAASF,CAAG,UAGtBS,IAAQ,YAAa,CAE5B,MAAMQ,EAAWT,EACjB,MAAML,EAAa,SAASH,EAAKE,EAAQe,CAAQ,CACnD,SAISR,IAAQ,QAEfJ,EAAa,KAAK,QAASL,EAAKE,EAAQC,EAAcC,EAAeC,CAAY,UAK1EI,IAAQ,qBAEfT,EAAI,QAAUE,EAAO,UAAU,GAC/BA,EAAO,UAAU,SAASF,CAAG,UAGtBS,IAAQ,uBAAwB,CAGvC,MAAMS,GADU,MAAMd,EAAc,KAAK,GACR,IAAIF,IAAmB,CAAE,GAAIA,EAAO,UAAU,GAAI,SAAUA,EAAO,UAAU,QAAS,EAAI,EAC3HF,EAAI,QAAUkB,EACdhB,EAAO,UAAU,SAASF,CAAG,CAC/B,SAESS,IAAQ,qBAAsB,CAErC,MAAMU,EAAQ,MAAMf,EAAc,SAAS,EAC3CJ,EAAI,QAAUmB,EACdjB,EAAO,UAAU,SAASF,CAAG,CAC/B,SAESS,IAAQ,uBAAwB,CAEvC,MAAMU,EAAQ,MAAMf,EAAc,WAAWJ,EAAI,IAAI,EACrDA,EAAI,QAAUmB,EACdjB,EAAO,UAAU,SAASF,CAAG,CAC/B,CAEF,CASA,YAAYC,EAAkB,CAC5B,MAAMmB,EAAgB,CAAC,KAAM,OAAQ,KAAM,MAAO,SAAS,EACrDC,EAAiB,CAAC,KAAM,OAAQ,KAAM,KAAK,EACjD,IAAItB,EAAK,GAGT,UAAWuB,KAAQrB,EACjB,GAAImB,EAAc,QAAQE,CAAI,IAAM,GAAI,CAAEvB,EAAK,GAAO,KAAO,CAI/D,UAAWwB,KAAiBF,EAC1B,GAAIpB,EAAiB,QAAQsB,CAAa,IAAM,GAAI,CAAExB,EAAK,GAAO,KAAO,CAG3E,OAAOA,CACT,CAGF,CA7MM,EAAAF,EAAA,WAiNN,QAAe,IAAIA,ECvNnB,MAAM2B,CAAI,CAER,aAAc,CACZ,KAAK,UAAY,GACnB,CAQA,SAAS1B,EAAQ,CACf,OAAAA,EAASA,EAAO,QAAQ,KAAK,UAAW,EAAE,EAC9BA,CAEd,CAUA,SAASE,EAAK,CACZ,IAAIF,EAASE,EACb,OAAI,OAAOA,GAAQ,WAAYF,EAAS,KAAK,UAAUE,CAAG,GAC1DF,GAAU,KAAK,UACRA,CACT,CASA,MAAM,SAAU,CAAE,CAGpB,CA3CM,EAAA0B,EAAA,OA8CN,QAAe,IAAIA,EC3CnB,MAAMC,CAAkB,CAKtB,YAAYC,EAAQ,CAGlB,GADA,KAAK,OAASA,EACV,CAACA,EAAO,OAAS,CAAC,WAAW,KAAKA,EAAO,KAAK,EAAK,MAAM,IAAI,MAAM,mBAAmB,EACrFA,EAAO,iBAAkB,KAAK,OAAO,eAAiB,KACvDA,EAAO,oBAAsB,SAAa,KAAK,OAAO,kBAAoB,GAC1EA,EAAO,iBAAmB,SAAa,KAAK,OAAO,eAAiB,KACpEA,EAAO,kBAAoB,SAAa,KAAK,OAAO,gBAAkB,MACrEA,EAAO,eAAgB,KAAK,OAAO,aAAe,CAAC,UAAW,KAAK,GAEnEA,EAAO,QAAS,KAAK,OAAO,MAAQ,IACpCA,EAAO,mBAAoB,KAAK,OAAO,iBAAmB,IAE/D,KAAK,QACL,KAAK,SACL,KAAK,QAAU,EACf,KAAK,eAEL,KAAK,OAASC,CAChB,CAQA,SAAU,CACR,KAAK,SAAW,KAAK,OAAO,WAAW,EACvC,IAAIC,EAAQ,KAAK,OAAO,MACxB,MAAI,gBAAgB,KAAKA,CAAK,EAAKA,GAAS,aAAa,KAAK,WACvDA,GAAS,YAAY,KAAK,WAEjC,KAAK,QAAU,IAAI,UAAUA,EAAO,KAAK,OAAO,YAAY,EAE5D,KAAK,SAAS,EAGP,IAAI,QAAQrC,GAAW,CAE5Bc,EAAa,KAAK,YAAa,IAAM,CAAEd,EAAQ,KAAK,OAAO,CAAG,CAAC,CAEjE,CAAC,CACH,CAMA,YAAa,CACL,KAAK,SAAW,KAAK,QAAQ,MAAM,EACzC,KAAK,eAAe,CACtB,CAOA,MAAM,WAAY,CAChB,MAAMsC,EAAW,KAAK,OAAO,kBACvBC,EAAQ,KAAK,OAAO,eACtB,KAAK,SAAWD,IAClB,MAAM,KAAK,OAAO,MAAMC,CAAK,EAC7B,KAAK,QAAQ,EACb,QAAQ,IAAI,sBAAsB,KAAK,cAAcD,QAAeC,KAAS,EAC7E,KAAK,UAET,CAMA,gBAAiB,CACf,KAAK,QAAU,KAAK,OAAO,kBAAoB,CACjD,CAOA,UAAW,CACT,KAAK,QAAQ,OAAS,MAAOC,GAAY,CACvC,QAAQ,IAAI,qCAAqC,KAAK,uCAAuC,KAAK,QAAQ,WAAW,EAErH,KAAK,UAAU,EAEf,KAAK,QAAU,EAGT,KAAK,SAAW,KAAK,QAAQ,WAAa,MAAS,KAAK,eAAiBC,EACpE,KAAK,SAAW,KAAK,QAAQ,WAAa,UAAa,KAAK,eAAiBC,EACjF,KAAK,eAAiBD,EAE7B3B,EAAa,KAAK,WAAW,CAC/B,EAGA,KAAK,QAAQ,QAAW6B,GAAa,CACnC,QAAQ,IAAI,sBAAsB,EAClC,OAAO,KAAK,QACZ,OAAO,KAAK,SACZ,KAAK,UAAU,EACf7B,EAAa,KAAK,cAAc,CAClC,EAGA,KAAK,QAAQ,QAAW8B,GAAa,CAErC,CACF,CASA,WAAY,CACV,GAAI,CAAC,KAAK,QAAW,OACrB,MAAMC,EAAc,KAAK,QAAQ,SAEjC,KAAK,QAAQ,iBAAiB,UAAWrD,GAAS,CAChD,GAAI,CACF,MAAMe,EAASf,EAAM,KAUrB,GATA,KAAK,UAAU,aAAce,CAAM,EAS/B,CADkB,IAAI,OAAO,KAAK,eAAe,SAAS,EAC3C,KAAKA,CAAM,EAAK,OAEnC,MAAME,EAAM,KAAK,eAAe,SAASF,CAAM,EAGzCnB,EAAS,CAAE,IAAAqB,EAAK,OAAAF,CAAO,EACzBE,EAAI,MAAQ,SAAWoC,IAAgB,UAAa/B,EAAa,KAAK,QAAS1B,CAAM,EAChFqB,EAAI,MAAQ,gBAAkBoC,IAAgB,WAAa,KAAK,eAAe,EAAG/B,EAAa,KAAK,eAAgB1B,CAAM,GAC1H,cAAc,KAAKqB,EAAI,GAAG,GAAKoC,IAAgB,UAAa/B,EAAa,KAAK,WAAY1B,CAAM,EAClG0B,EAAa,KAAK,UAAW1B,CAAM,CAE5C,OAASqC,EAAP,CACAX,EAAa,KAAK,gBAAiBW,CAAG,CACxC,CACF,CAAC,CAEH,CAWA,MAAM,SAASR,EAAIC,EAAKC,EAAS,CAC/B,MAAMJ,EAAK,KAAK,OAAO,WAAW,EAC5BC,EAAO,KAAK,SAGlB,GAAI,CAAC,MAAM,QAAQC,CAAE,GAAK,OAAOA,GAAO,SACtC,MAAM,IAAI,MAAM,2CAA2C,EACtD,GAAI,MAAM,QAAQA,CAAE,GACzB,UAAW6B,KAAK7B,EACd,GAAI,OAAO6B,GAAM,SAAY,MAAM,IAAI,MAAM,2CAA2C,EAI5F,MAAMrC,EAAM,CAAE,GAAAM,EAAI,KAAAC,EAAM,GAAAC,EAAI,IAAAC,EAAK,QAAAC,CAAQ,EACnCZ,EAAS,KAAK,eAAe,SAASE,CAAG,EAC/C,aAAM,KAAK,YAAYF,CAAM,EAE7B,KAAK,UAAU,SAAUA,CAAM,EAExBE,CACT,CAQA,MAAM,YAAYF,EAAQ,CAExB,GADA,MAAM,IAAI,QAAQwC,GAAK,WAAWA,EAAG,CAAC,CAAC,EACjC,KAAK,SAAW,KAAK,QAAQ,aAAe,EAAK,KAAK,QAAQ,KAAKxC,CAAM,MACxE,OAAM,IAAI,MAAM,yCAA0C,CACnE,CASA,MAAM,QAAQU,EAAIE,EAAS,CACzB,MAAMD,EAAM,iBACZ,OAAO,MAAM,KAAK,SAASD,EAAIC,EAAKC,CAAO,CAC7C,CASA,MAAM,KAAKF,EAAIE,EAAS,CACtB,MAAMD,EAAM,cACZ,OAAO,MAAM,KAAK,SAASD,EAAIC,EAAKC,CAAO,CAC7C,CAQA,MAAM,UAAUA,EAAS,CACvB,MAAMF,EAAK,IACLC,EAAM,mBACZ,OAAO,MAAM,KAAK,SAASD,EAAIC,EAAKC,CAAO,CAC7C,CAOA,MAAM,QAAQA,EAAS,CACrB,MAAMF,EAAK,IACLC,EAAM,iBACZ,OAAO,MAAM,KAAK,SAASD,EAAIC,EAAKC,CAAO,CAC7C,CAYA,MAAM,SAASD,EAAK,CAElB,MAAMD,EAAK,KAAK,SACVE,EAAU,OAChB,aAAM,KAAK,SAASF,EAAIC,EAAKC,CAAO,EAG7B,IAAI,QAAQ,MAAOnB,EAASgD,IAAW,CAC5C,MAAM1D,EAAW,EAAAmB,GAAO,CAAMA,EAAI,MAAQS,GAAOlB,EAAQS,CAAG,CAAK,EAAhD,YACjB,KAAK,KAAK,WAAYnB,CAAQ,EAC9B,MAAM,KAAK,OAAO,MAAM,KAAK,OAAO,eAAe,EACnD,KAAK,IAAI,WAAYA,CAAQ,EAC7B0D,EAAO,IAAI,MAAM,+BAA+B9B,GAAK,CAAC,CACxD,CAAC,CACH,CAOA,MAAM,kBAAmB,CACvB,MAAM+B,EAAS,MAAM,KAAK,SAAS,oBAAoB,EACvD,YAAK,SAAWA,EAAO,QAChB,KAAK,QACd,CAMA,MAAM,oBAAqB,CAEzB,OADe,MAAM,KAAK,SAAS,sBAAsB,GAC3C,OAChB,CAMA,MAAM,kBAAmB,CAEvB,OADe,MAAM,KAAK,SAAS,oBAAoB,GACzC,OAChB,CAMA,MAAM,oBAAqB,CAEzB,OADe,MAAM,KAAK,SAAS,sBAAsB,GAC3C,OAChB,CAWA,MAAM,UAAUvB,EAAU,CACxB,MAAMT,EAAK,IACLC,EAAM,aACNC,EAAUO,EAChB,OAAO,MAAM,KAAK,SAAST,EAAIC,EAAKC,CAAO,CAC7C,CAOA,MAAM,SAASO,EAAU,CACvB,MAAMT,EAAK,IACLC,EAAM,YACNC,EAAUO,EAChB,OAAO,MAAM,KAAK,SAAST,EAAIC,EAAKC,CAAO,CAC7C,CAMA,MAAM,aAAc,CAClB,MAAMF,EAAK,IACLC,EAAM,eAEZ,OAAO,MAAM,KAAK,SAASD,EAAIC,EAAK,MAAO,CAC7C,CAQA,MAAM,SAASQ,EAAUP,EAAS,CAChC,MAAMF,EAAKS,EACLR,EAAM,YACZ,OAAO,MAAM,KAAK,SAASD,EAAIC,EAAKC,CAAO,CAC7C,CAUA,MAAM,QAAQK,EAAU,CACtB,MAAMP,EAAK,IACLC,EAAM,cACNC,EAAUK,EAChB,OAAO,MAAM,KAAK,SAASP,EAAIC,EAAKC,CAAO,CAC7C,CASA,MAAM,MAAM+B,EAAKC,EAAM,CACrB,MAAMlC,EAAK,IACLC,EAAM,QACNC,EAAU,CAAE,IAAA+B,EAAK,KAAAC,CAAK,EAC5B,OAAO,MAAM,KAAK,SAASlC,EAAIC,EAAKC,CAAO,CAC7C,CAWA,GAAGhC,EAAWG,EAAU,CACtBwB,EAAa,GAAG3B,EAAWG,CAAQ,CACrC,CAOA,KAAKH,EAAWG,EAAU,CACxB,OAAOwB,EAAa,KAAK3B,EAAWG,CAAQ,CAC9C,CAOA,IAAIH,EAAWG,EAAU,CACvB,OAAOwB,EAAa,IAAI3B,EAAWG,CAAQ,CAC7C,CAMA,OAAOH,EAAW,CAChB,OAAO2B,EAAa,OAAO3B,CAAS,CACtC,CASA,aAAaiE,EAAW,CACtB,MAAMC,EAAOD,EAAU,KAAK,EAAE,EAC1B,KAAK,OAAO,OAAS,QAAQ,IAAIC,CAAI,CAC3C,CAGF,CA9bM,EAAAnB,EAAA,qBCRN,MAAMoB,ED0cSpB,ECncX,OAAO,OAAW,MACf,OAAO,WAAY,OAAO,SAAW,CAAC,GAC3C,OAAO,SAAS,gBAAkBoB,E","sources":["webpack://@mikosoft/ws-client-browser/./src/lib/eventEmitter.js","webpack://@mikosoft/ws-client-browser/./src/lib/helper.js","webpack://@mikosoft/ws-client-browser/./src/lib/subprotocol/jsonRWS.js","webpack://@mikosoft/ws-client-browser/./src/lib/subprotocol/raw.js","webpack://@mikosoft/ws-client-browser/./src/ws-clients/WsClientBrowser13.js","webpack://@mikosoft/ws-client-browser/./index.js"],"sourcesContent":["/**\n * The EventEmitter based on window CustomEvent. Inspired by the NodeJS event lib.\n */\nclass EventEmitter {\n\n  constructor() {\n    this.activeOns = []; // [{eventName:string, listener:Function, listenerWindow:Function}]\n  }\n\n\n  /**\n   * Create and emit the event\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {any} detail - event argument\n   * @returns {void}\n   */\n  emit(eventName, detail = {}) {\n    const evt = new CustomEvent(eventName, { detail });\n    window.dispatchEvent(evt);\n  }\n\n\n  /**\n   * Listen for the event\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {Function} listener - callback function, for example msg => {...}\n   * @returns {void}\n   */\n  on(eventName, listener) {\n    const listenerWindow = event => {\n      const detailValues = this._getDetailValues(event.detail);\n      listener.call(null, ...detailValues);\n    };\n\n    this._removeOne(eventName, listener);\n    this.activeOns.push({ eventName, listener, listenerWindow });\n    window.addEventListener(eventName, listenerWindow);\n  }\n\n\n  /**\n   * Listen for the event only once\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {Function} listener - callback function\n   * @returns {void}\n   */\n  once(eventName, listener) {\n    const listenerWindow = event => {\n      const detailValues = this._getDetailValues(event.detail);\n      listener.call(null, ...detailValues);\n\n      this._removeOne(eventName, listener, listenerWindow);\n    };\n\n    window.addEventListener(eventName, listenerWindow, { once: true });\n  }\n\n\n  /**\n   * Stop listening the event for specific listener.\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {Function} listener - callback function, for example msg => {...}\n   * @returns {void}\n   */\n  off(eventName, listener) {\n    this._removeOne(eventName, listener);\n  }\n\n\n  /**\n   * Stop listening the event for all listeners defined with on().\n   * For example eventEmitter.on('msg', fja1) & eventEmitter.on('msg', fja2) then eventEmitter.off('msg') will remove fja1 and fja2 listeners.\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @returns {void}\n   */\n  offAll(eventName) {\n    let ind = 0;\n    for (const activeOn of this.activeOns) {\n      if (activeOn.eventName === eventName) {\n        window.removeEventListener(activeOn.eventName, activeOn.listenerWindow);\n        this.activeOns.splice(ind, 1);\n      }\n      ind++;\n    }\n  }\n\n\n  /**\n   * Get all active listeners.\n   * @returns {{eventName:string, listener:Function, listenerWindow:Function}[]}\n   */\n  getListeners() {\n    return { ...this.activeOns };\n  }\n\n\n\n\n\n  /*** PRIVATES ***/\n  /**\n   * Remove a listener from window and this.activeOns\n   */\n  _removeOne(eventName, listener) {\n    if (!listener) { throw new Error('eventEmitter._removeOne Error: listener is not defined'); }\n    let ind = 0;\n    for (const activeOn of this.activeOns) {\n      if (activeOn.eventName === eventName && activeOn.listener.toString() === listener.toString()) {\n        window.removeEventListener(activeOn.eventName, activeOn.listenerWindow);\n        this.activeOns.splice(ind, 1);\n      }\n      ind++;\n    }\n  }\n\n\n  /**\n   * Get values from the event.detail object\n   * @param {object} detail - event.detail object, for example {msg, msgSTR}\n   * @returns {Array} - an array of the detail values (selected by the listener arguments)\n   */\n  _getDetailValues(detail) {\n    const detailValues = !!detail ? Object.values(detail) : [];\n    return detailValues;\n  }\n\n\n\n\n\n}\n\n\nexport default new EventEmitter();\n","class Helper {\n\n  /**\n   * Create unique id. It's combination of timestamp and random number 'r'\n   * in format: YYYYMMDDHHmmssSSSrrr ---> YYYY year, MM month, DD day, HH hour, mm min, ss sec, SSS ms, rrr 3 random digits\n   * 20 digits in total, for example: '20210129163129492100'\n   * @returns {string}\n   */\n  generateID() {\n    const rnd = Math.random().toString();\n    const rrr = rnd.replace('0.', '').substring(0, 3);\n\n    const timestamp = new Date(); // UTC (Greenwich time)\n    const tsp = timestamp.toISOString()\n      .replace(/\\-/g, '')\n      .replace(/\\:/g, '')\n      .replace('T', '')\n      .replace('Z', '')\n      .replace('.', '');\n\n    const id = tsp + rrr;\n    return id;\n  }\n\n\n  /**\n   * Gives now time in nice format -> Friday, 1/29/2021, 16:31:29.801\n   * @returns {string}\n   */\n  nowTime() {\n    const now = new Date();\n    const formatter = new Intl.DateTimeFormat('en-us', {\n      weekday: 'long',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      fractionalSecondDigits: 3,\n      hour12: false,\n      timeZone: 'UTC'\n    });\n    return formatter.format(now);\n  }\n\n\n  /**\n   * Pause the code execution\n   * @param {number} ms - miliseconds\n   * @returns {Promise}\n   */\n  async sleep(ms) {\n    await new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n\n\n  /**\n   * Print all buffer values as string. The bytes are printed separately, for example byte 81, byte 7e ...etc\n   * For example: 81 7e 00 8b 7b 22 69 64 22 3a 32 31 30 32 31 34 31 30\n   * @param {Buffer} buff\n   * @returns {void}\n   */\n  printBuffer(buff) {\n    console.log(buff.toString('hex').match(/../g).join(' '));\n  }\n\n\n  /**\n   * Print buffer in nice table of bytes.\n   * @param {Buffer} buff - bytes\n   * @param {number} perRow - how many bytes present per row (per line)\n   */\n  tableOfBytes(buff, perRow) {\n    let bytes = buff.toString('hex').match(/../g);\n\n    // add new line\n    bytes = bytes.map((byte, key) => {\n      if (key === 0) { byte = '\\n ' + byte; }\n      if ((key + 1) % perRow === 0) { byte += '\\n'; }\n      return byte;\n    });\n\n    const str = bytes.join(' ');\n    return str;\n  }\n\n\n}\n\n\n\n\nexport default new Helper();\n","/**\n * Subprotocol name: jsonRWS\n * HTTP header: \"Sec-WebSocket-Protocol\": \"jsonRWS\"\n *\n * Subprotocol description:\n *  This subprotocol is created for communication between websocket server and client.\n *\n * Subprotocol definitons:\n *  a) Client have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  b) Server have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  c) The message is converted from string to object.\n *  d) The data type definition of the sent object: {id:string, from:string, to:string, cmd:string, payload?:any}\n */\n\n\nclass JsonRWS {\n\n  constructor() {\n    this.delimiter = '\\u0003';  // end-of-text unicode character\n  }\n\n  /*********** INCOMING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for incoming messages. Filter and map incoming messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:string, from:string, to:string|string[], cmd:string, payload?:any}.\n   * 2. Convert the message from string to object.\n   * @param {string} msgSTR -incoming message\n   * @returns {{id:string, from:string, to:numstringber|string[], cmd:string, payload?:any}}\n   */\n  incoming(msgSTR) {\n    let tf = false;\n    let msg;\n    try {\n      msgSTR = msgSTR.replace(this.delimiter, ''); // remove delimiter\n      msg = JSON.parse(msgSTR);\n      const msgObjProperties = Object.keys(msg);\n      tf = this._testFields(msgObjProperties);\n    } catch (err) {\n      tf = false;\n    }\n\n    if (tf) { return msg; }\n    else { throw new Error(`Incoming message doesn\\'t have valid \"jsonRWS\" subprotocol format. msg:: \"${msgSTR}\"`); }\n  }\n\n\n\n  /*********** OUTGOING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for outgoing messages. Filter and map outgoing messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:string, from:string, to:string|string[], cmd:string, payload:any}.\n   * 2. Convert the message from object to string.\n   * @param {{id:string, from:string, to:string|string[], cmd:string, payload?:any}} msg - outgoing message\n   * @returns {string}\n   */\n  outgoing(msg) {\n    const msgObjProperties = Object.keys(msg);\n    const tf = this._testFields(msgObjProperties);\n\n    if (tf) {\n      const msgSTR = JSON.stringify(msg) + this.delimiter;\n      return msgSTR;\n    } else {\n      throw new Error(`Outgoing message doesn\\'t have valid \"jsonRWS\" subprotocol format. msg:: ${JSON.stringify(msg)}`);\n    }\n  }\n\n\n\n  /*********** PROCESS MESSAGES ***********/\n  /**\n   * Process client messages internally.\n   * @param {object} msg - instruction message - {id, from, to, cmd, payload}\n   * @param {Socket} socket - client which received the message\n   * @param {DataTransfer} dataTransfer - instance of the DataTransfer\n   * @param {SocketStorage} socketStorage - instance of the SockketStorage\n   * @param {EventEmitter} eventEmitter - event emitter initiated in the RWS.js\n   */\n  async processing(msg, socket, dataTransfer, socketStorage, eventEmitter) {\n    const id = msg.id;\n    const from = msg.from;\n    const to = msg.to;\n    const cmd = msg.cmd;\n    const payload = msg.payload;\n\n\n    /*** socket commands ***/\n    if (cmd === 'socket/sendone') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '20210201164339351900', cmd: 'socket/sendone', payload: 'Some message to another client'}\n      const id = msg.to;\n      const toSocket = await socketStorage.findOne({ id });\n      await dataTransfer.sendOne(msg, toSocket);\n    }\n\n    else if (cmd === 'socket/send') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: ['20210201164339351900', '210201164339351901'], cmd: 'socket/send', payload: 'Some message to another client(s)'}\n      const socketIDs = to.map(socketID => socketID); // convert to numbers\n      const sockets = await socketStorage.find({ id: { $in: socketIDs } });\n      await dataTransfer.send(msg, sockets);\n    }\n\n    else if (cmd === 'socket/broadcast') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'socket/broadcast', payload: 'Some message to all clients except the sender'}\n      await dataTransfer.broadcast(msg, socket);\n    }\n\n    else if (cmd === 'socket/sendall') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'socket/sendall', payload: 'Some message to all clients and the sender'}\n      await dataTransfer.sendAll(msg);\n    }\n\n    else if (cmd === 'socket/nick') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'socket/nick', payload: 'Peter Pan'}\n      const nickname = msg.payload;\n      try {\n        await socketStorage.setNick(socket, nickname);\n        msg.payload = socket.extension.nickname;\n      } catch (err) {\n        msg.cmd = 'error';\n        msg.payload = err.message;\n      }\n      socket.extension.sendSelf(msg);\n    }\n\n\n    /*** room commands ***/\n    else if (cmd === 'room/enter') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'room/enter', payload: 'My Chat Room'}\n      const roomName = payload;\n      socketStorage.roomEnter(socket, roomName);\n      msg.payload = `Entered in the room '${roomName}'`;\n      socket.extension.sendSelf(msg);\n    }\n\n    else if (cmd === 'room/exit') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'room/exit', payload: 'My Chat Room'}\n      const roomName = payload;\n      socketStorage.roomExit(socket, payload);\n      msg.payload = `Exited from the room '${roomName}'`;\n      socket.extension.sendSelf(msg);\n    }\n\n    else if (cmd === 'room/exitall') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'room/exitall'}\n      socketStorage.roomExitAll(socket);\n      msg.payload = 'Exited from all rooms';\n      socket.extension.sendSelf(msg);\n    }\n\n    else if (cmd === 'room/send') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: 'My Chat Room', cmd: 'room/send', payload: 'Some message to room clients.'}\n      const roomName = to;\n      await dataTransfer.sendRoom(msg, socket, roomName);\n    }\n\n\n    /*** route command ***/\n    else if (cmd === 'route') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '0', cmd: 'route', payload: {uri: 'shop/login', body: {username:'mark', password:'thG5$#w'}}}\n      eventEmitter.emit('route', msg, socket, dataTransfer, socketStorage, eventEmitter);\n    }\n\n\n    /*** question commands ***/\n    else if (cmd === 'question/socket/id') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '20210129163129492111', cmd: 'question/socket/id'}\n      msg.payload = socket.extension.id;\n      socket.extension.sendSelf(msg);\n    }\n\n    else if (cmd === 'question/socket/list') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '20210129163129492111', cmd: 'question/socket/list'}\n      const sockets = await socketStorage.find();\n      const socket_ids_nicks = sockets.map(socket => { return { id: socket.extension.id, nickname: socket.extension.nickname }; });\n      msg.payload = socket_ids_nicks; // {id:string, nickname:string}\n      socket.extension.sendSelf(msg);\n    }\n\n    else if (cmd === 'question/room/list') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '20210129163129492111', cmd: 'question/room/list'}\n      const rooms = await socketStorage.roomList();\n      msg.payload = rooms;\n      socket.extension.sendSelf(msg);\n    }\n\n    else if (cmd === 'question/room/listmy') {\n      // {id: '20210129163129492000', from: '20210129163129492111', to: '20210129163129492111', cmd: 'question/room/listmy'}\n      const rooms = await socketStorage.roomListOf(msg.from);\n      msg.payload = rooms;\n      socket.extension.sendSelf(msg);\n    }\n\n  }\n\n\n\n  /******* HELPERS ********/\n  /**\n   * Helper to test msg properties.\n   * @param {string[]} msgObjProperties - properties of the \"msg\" object\n   */\n  _testFields(msgObjProperties) {\n    const allowedFields = ['id', 'from', 'to', 'cmd', 'payload'];\n    const requiredFields = ['id', 'from', 'to', 'cmd'];\n    let tf = true;\n\n    // check if every of the msg properties are in allowed fields\n    for (const prop of msgObjProperties) {\n      if (allowedFields.indexOf(prop) === -1) { tf = false; break; }\n    }\n\n    // check if every of required fields is present\n    for (const requiredField of requiredFields) {\n      if (msgObjProperties.indexOf(requiredField) === -1) { tf = false; break; }\n    }\n\n    return tf;\n  }\n\n\n}\n\n\n\nexport default new JsonRWS();\n","/**\n * Subprotocol name: raw\n * HTTP header: \"Sec-WebSocket-Protocol\": \"raw\"\n *\n * Subprotocol description:\n *  The simplest subprotocol.\n */\n\n\nclass Raw {\n\n  constructor() {\n    this.delimiter = '\\u0003'; // end-of-text unicode character\n  }\n\n  /*********** INCOMING MESSAGES ***********/\n  /**\n   * Execute the subprotocol for incoming messages.\n   * @param {string} msgSTR -incoming message\n   * @returns {string}\n   */\n  incoming(msgSTR) {\n    msgSTR = msgSTR.replace(this.delimiter, ''); // remove delimiter\n    const msg = msgSTR;\n    return msg;\n  }\n\n\n\n  /*********** OUTGOING MESSAGES ***********/\n  /**\n   * Execute the subprotocol for outgoing messages.\n   * @param {any} msg - outgoing message\n   * @returns {string}\n   */\n  outgoing(msg) {\n    let msgSTR = msg;\n    if (typeof msg === 'object') { msgSTR = JSON.stringify(msg); }\n    msgSTR += this.delimiter;\n    return msgSTR;\n  }\n\n\n\n  /*********** PROCESS MESSAGES ***********/\n  /**\n   * Process client messages internally.\n   * @returns {void}\n   */\n  async process() { }\n\n\n}\n\n\nexport default new Raw();\n","/**\n * Websocket Client for Browser\n * - websocket version: 13\n * - subprotocols: raw, jsonRWS\n */\nimport eventEmitter from '../lib/eventEmitter.js';\nimport helper from '../lib/helper.js';\nimport jsonRWS from '../lib/subprotocol/jsonRWS.js';\nimport raw from '../lib/subprotocol/raw.js';\n\n\n\nclass WsClientBrowser13 {\n\n  /**\n   * @param {{wsURL:string, questionTimeout:number, reconnectAttempts:number, reconnectDelay:number, subprotocols:string[], debug:boolean}} wcOpts - websocket client options\n   */\n  constructor(wcOpts) {\n    // websocket client default options\n    this.wcOpts = wcOpts;\n    if (!wcOpts.wsURL || !/^ws:\\/\\//.test(wcOpts.wsURL)) { throw new Error('Bad websocket URL'); } // HTTP request timeout i.e. websocket connect timeout (when internet is down or on localhost $ sudo ip link set lo down)\n    if (!wcOpts.connectTimeout) { this.wcOpts.connectTimeout = 8000; } // HTTP request timeout i.e. websocket connect timeout (when internet is down or on localhost $ sudo ip link set lo down)\n    if (wcOpts.reconnectAttempts === undefined) { this.wcOpts.reconnectAttempts = 6; } // how many times to try to reconnect when connection with the server is lost\n    if (wcOpts.reconnectDelay === undefined) { this.wcOpts.reconnectDelay = 5000; } // delay between reconnections, default is 3 seconds\n    if (wcOpts.questionTimeout === undefined) { this.wcOpts.questionTimeout = 13000; } // how many mss to wait for the answer when question is sent\n    if (!wcOpts.subprotocols) { this.wcOpts.subprotocols = ['jsonRWS', 'raw']; } // list of the supported subprotocols\n    // if (wcOpts.autodelayFactor === undefined) { this.wcOpts.autodelayFactor = 500; } // factor for preventing DDoS, bigger then sending messages works slower\n    if (!wcOpts.debug) { this.wcOpts.debug = false; }\n    if (!wcOpts.debug_DataParser) { this.wcOpts.debug_DataParser = false; } // ws message level debugging\n\n    this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n    this.socketID; // socket ID number, for example: 20210214082949459100\n    this.attempt = 1; // reconnect attempt counter\n    this.subprotocolLib;\n\n    this.helper = helper;\n  }\n\n\n  /************* CLIENT CONNECTOR ************/\n  /**\n   * Connect to the websocket server.\n   * @returns {Promise<WebSocket>}\n   */\n  connect() {\n    this.socketID = this.helper.generateID();\n    let wsURL = this.wcOpts.wsURL; // websocket URL: ws://localhost:3211/something?authkey=TRTmrt\n    if (/\\?[a-zA-Z0-9]/.test(wsURL)) { wsURL += `&socketID=${this.socketID}`; }\n    else { wsURL += `socketID=${this.socketID}`; }\n\n    this.wsocket = new WebSocket(wsURL, this.wcOpts.subprotocols);\n\n    this.onEvents();\n\n    // return socket as promise\n    return new Promise(resolve => {\n      // eventEmitter.removeAllListeners(); // not needed if once() is used\n      eventEmitter.once('connected', () => { resolve(this.wsocket); });\n      // console.log(`\"connected\" listeners: ${eventEmitter.listenerCount('connected')}`.cliBoja('yellow'));\n    });\n  }\n\n\n  /**\n   * Disconnect from the websocket server.\n   */\n  disconnect() {\n    if (!!this.wsocket) { this.wsocket.close(); }\n    this.blockReconnect();\n  }\n\n\n  /**\n   * Try to reconnect the client when the socket is closed.\n   * This method is fired on every 'close' socket's event.\n   */\n  async reconnect() {\n    const attempts = this.wcOpts.reconnectAttempts;\n    const delay = this.wcOpts.reconnectDelay;\n    if (this.attempt <= attempts) {\n      await this.helper.sleep(delay);\n      this.connect();\n      console.log(`Reconnect attempt #${this.attempt} of ${attempts} in ${delay}ms`);\n      this.attempt++;\n    }\n  }\n\n\n  /**\n   * Block reconnect usually after disconnect() method is used.\n   */\n  blockReconnect() {\n    this.attempt = this.wcOpts.reconnectAttempts + 1;\n  }\n\n\n\n  /**\n   * Event listeners.\n   */\n  onEvents() {\n    this.wsocket.onopen = async (openEvt) => {\n      console.log(`WS Connection opened -- socketID: ${this.socketID}, subprotocol(handshaked): \"${this.wsocket.protocol}\"`);\n\n      this.onMessage();\n\n      this.attempt = 1;\n\n      // define subprotocol library\n      if (!!this.wsocket && this.wsocket.protocol === 'raw') { this.subprotocolLib = raw; }\n      else if (!!this.wsocket && this.wsocket.protocol === 'jsonRWS') { this.subprotocolLib = jsonRWS; }\n      else { this.subprotocolLib = raw; }\n\n      eventEmitter.emit('connected');\n    };\n\n\n    this.wsocket.onclose = (closeEvt) => {\n      console.log('WS Connection closed');\n      delete this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n      delete this.socketID;\n      this.reconnect();\n      eventEmitter.emit('disconnected');\n    };\n\n\n    this.wsocket.onerror = (errorEvt) => {\n      // console.error(errorEvt);\n    };\n  }\n\n\n\n  /************* RECEIVERS ************/\n  /**\n   * Receive the message as buffer and convert it in the appropriate subprotocol format.\n   * If toEmit is true push it to eventEmitter as 'message' event.\n   */\n  onMessage() {\n    if (!this.wsocket) { return; }\n    const subprotocol = this.wsocket.protocol; // jsonRWS || raw\n\n    this.wsocket.addEventListener('message', event => {\n      try {\n        const msgSTR = event.data;\n        this._debugger('Received::', msgSTR);\n\n        /**\n           * Test if the message contains the delimiter.\n           * Delimiter is important because the network is splitting large message in the chunks of data so we need to know when the message reached the end and new message is starting.\n           * A TCP network chunk is around 1500 bytes. To check it use linux command: $ ifconfig | grep -i MTU\n           * Related terms are TCP MTU (Maximum Transmission Unit) and TCP MSS (Maximum Segment Size) --> (MSS = MTU - TCPHdrLen - IPHdrLen)\n           */\n        const delimiter_reg = new RegExp(this.subprotocolLib.delimiter);\n        if (!delimiter_reg.test(msgSTR)) { return; }\n\n        const msg = this.subprotocolLib.incoming(msgSTR);\n\n        // dispatch\n        const detail = { msg, msgSTR };\n        if (msg.cmd === 'route' && subprotocol === 'jsonRWS') { eventEmitter.emit('route', detail); }\n        else if (msg.cmd === 'server-error' && subprotocol === 'jsonRWS') { this.blockReconnect(); eventEmitter.emit('server-error', detail); }\n        else if (/^question\\//.test(msg.cmd) && subprotocol === 'jsonRWS') { eventEmitter.emit('question', detail); }\n        else { eventEmitter.emit('message', detail); }\n\n      } catch (err) {\n        eventEmitter.emit('message-error', err);\n      }\n    });\n\n  }\n\n\n  /************* SENDERS ************/\n  /**\n   * Send message to the websocket server if the connection is not closed (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState).\n   * @param {string|string[]} to - final destination: 210201164339351900\n   * @param {string} cmd - command\n   * @param {any} payload - message payload\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async carryOut(to, cmd, payload) {\n    const id = this.helper.generateID(); // the message ID\n    const from = this.socketID; // the sender ID\n\n    // test if \"to\" is string\n    if (!Array.isArray(to) && typeof to !== 'string') {\n      throw new Error('ERRcarryOut: \"to\" argument must be string');\n    } else if (Array.isArray(to)) {\n      for (const t of to) {\n        if (typeof t !== 'string') { throw new Error('ERRcarryOut: \"to\" argument must be string'); }\n      }\n    }\n\n    const msg = { id, from, to, cmd, payload };\n    const msgSTR = this.subprotocolLib.outgoing(msg);\n    await this.socketWrite(msgSTR);\n\n    this._debugger('Sent::', msgSTR);\n\n    return msg;\n  }\n\n\n  /**\n   * Check if socket is writable and not closed (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState)\n   * and send message in string format.\n   * @param {Buffer} msgSTR - message to server\n   */\n  async socketWrite(msgSTR) {\n    await new Promise(r => setTimeout(r, 0));\n    if (!!this.wsocket && this.wsocket.readyState === 1) { this.wsocket.send(msgSTR); }\n    else { throw new Error('Socket is not writeble or doesn\\'t exist'); }\n  }\n\n\n  /**\n   * Send message (payload) to one client.\n   * @param {string} to - 210201164339351900\n   * @param {any} payload - message sent to the client\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async sendOne(to, payload) {\n    const cmd = 'socket/sendone';\n    return await this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to one or more clients.\n   * @param {string[]} to - [210205081923171300, 210205082042463230]\n   * @param {any} payload - message sent to the clients\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async send(to, payload) {\n    const cmd = 'socket/send';\n    return await this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to all clients except the sender.\n   * @param {any} payload - message sent to the clients\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async broadcast(payload) {\n    const to = '0';\n    const cmd = 'socket/broadcast';\n    return await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message (payload) to all clients and the sender.\n   * @param {any} payload - message sent to the clients\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async sendAll(payload) {\n    const to = '0';\n    const cmd = 'socket/sendall';\n    return await this.carryOut(to, cmd, payload);\n  }\n\n\n\n  /******************************* QUESTIONS ******************************/\n  /*** Send a question to the websocket server and wait for the answer. ***/\n\n  /**\n   * Send question and expect the answer.\n   * @param {string} cmd - command\n   * @returns {Promise<object>}\n   */\n  async question(cmd) {\n    // send the question\n    const to = this.socketID;\n    const payload = undefined;\n    await this.carryOut(to, cmd, payload);\n\n    // receive the answer\n    return new Promise(async (resolve, reject) => {\n      const listener = msg => { if (msg.cmd === cmd) { resolve(msg); } };\n      this.once('question', listener);\n      await this.helper.sleep(this.wcOpts.questionTimeout);\n      this.off('question', listener);\n      reject(new Error(`No answer for the question: ${cmd}`));\n    });\n  }\n\n\n  /**\n   * Send question about my socket ID.\n   * @returns {Promise<number>}\n   */\n  async questionSocketId() {\n    const answer = await this.question('question/socket/id');\n    this.socketID = answer.payload;\n    return this.socketID;\n  }\n\n  /**\n   * Send question about all socket IDs connected to the server.\n   * @returns {Promise<number[]>}\n   */\n  async questionSocketList() {\n    const answer = await this.question('question/socket/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms in the server.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async questionRoomList() {\n    const answer = await this.question('question/room/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms where the client was entered.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async questionRoomListmy() {\n    const answer = await this.question(`question/room/listmy`);\n    return answer.payload;\n  }\n\n\n\n\n  /************* ROOMS ************/\n  /**\n   * Subscribe in the room.\n   * @param {string} roomName\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async roomEnter(roomName) {\n    const to = '0';\n    const cmd = 'room/enter';\n    const payload = roomName;\n    return await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from the room.\n   * @param {string} roomName\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async roomExit(roomName) {\n    const to = '0';\n    const cmd = 'room/exit';\n    const payload = roomName;\n    return await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from all rooms.\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async roomExitAll() {\n    const to = '0';\n    const cmd = 'room/exitall';\n    const payload = undefined;\n    return await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message to all clients in the specific room excluding the client who sent the message.\n   * @param {string} roomName\n   * @param {any} payload\n   * @return {object} full websocket message object {id, from, to, cmd, payload}\n   */\n  async roomSend(roomName, payload) {\n    const to = roomName;\n    const cmd = 'room/send';\n    return await this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /********* MISC *********/\n  /**\n   * Setup a nick name.\n   * @param {string} nickname - nick name\n   */\n  async setNick(nickname) {\n    const to = '0';\n    const cmd = 'socket/nick';\n    const payload = nickname;\n    return await this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send route command.\n   * @param {string} uri - route URI, for example /shop/product/55\n   * @param {any} body - body\n   * @return {object} message object {id, from, to, cmd, payload}\n   */\n  async route(uri, body) {\n    const to = '0';\n    const cmd = 'route';\n    const payload = { uri, body };\n    return await this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /*********** LISTENERS ************/\n  /**\n   * Listen the event.\n   * @param {string} eventName - event name: 'connected', 'disconnected', 'message', 'message-error', 'route', 'question', 'server-error'\n   * @param {Function} listener - callback function, for example: (msg, msgSTR) => { console.log(msgSTR); }\n   */\n  on(eventName, listener) {\n    eventEmitter.on(eventName, listener);\n  }\n\n  /**\n   * Listen the event only one time.\n   * @param {string} eventName - event name: 'connected', 'disconnected', 'message', 'message-error', 'route', 'question', 'server-error'\n   * @param {Function} listener - callback function, for example: (msg, msgSTR) => { console.log(msgSTR); }\n   */\n  once(eventName, listener) {\n    return eventEmitter.once(eventName, listener);\n  }\n\n  /**\n   * Stop listening the event.\n   * @param {string} eventName - event name: 'connected', 'disconnected', 'message', 'message-error', 'route', 'question', 'server-error'\n   * @param {Function} listener - callback function, for example: (msg, msgSTR) => { console.log(msgSTR); }\n   */\n  off(eventName, listener) {\n    return eventEmitter.off(eventName, listener);\n  }\n\n  /**\n   * Stop listening all events.\n   * @param {string} eventName - event name: 'connected', 'disconnected', 'message', 'message-error', 'route', 'question', 'server-error'\n   */\n  offAll(eventName) {\n    return eventEmitter.offAll(eventName);\n  }\n\n\n\n\n  /******* AUX ********/\n  /**\n   * Debugger. Use it as this._debugger(var1, var2, var3)\n   */\n  _debugger(...textParts) {\n    const text = textParts.join('');\n    if (this.wcOpts.debug) { console.log(text); }\n  }\n\n\n}\n\n\n\nexport default WsClientBrowser13;\n","import WsClientBrowser13 from './src/ws-clients/WsClientBrowser13.js';\n\n\n// default\nconst WsClientBrowser = WsClientBrowser13;\n\n// ESM\nexport { WsClientBrowser };\n\n\n// window\nif (typeof window !== 'undefined') {\n  if (!window.mikosoft) { window.mikosoft = {}; }\n  window.mikosoft.WsClientBrowser = WsClientBrowser;\n}\n"],"names":["EventEmitter","eventName","detail","evt","listener","listenerWindow","event","detailValues","ind","activeOn","Helper","rrr","now","ms","resolve","buff","perRow","bytes","byte","key","JsonRWS","msgSTR","tf","msg","msgObjProperties","socket","dataTransfer","socketStorage","eventEmitter","id","from","to","cmd","payload","toSocket","socketIDs","socketID","sockets","nickname","err","roomName","socket_ids_nicks","rooms","allowedFields","requiredFields","prop","requiredField","Raw","WsClientBrowser13","wcOpts","helper","wsURL","attempts","delay","openEvt","raw","jsonRWS","closeEvt","errorEvt","subprotocol","t","r","reject","answer","uri","body","textParts","text","WsClientBrowser"],"sourceRoot":""}